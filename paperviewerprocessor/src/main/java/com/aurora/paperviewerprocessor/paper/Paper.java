package com.aurora.paperviewerprocessor.paper;

import android.graphics.Bitmap;

import com.aurora.auroralib.PluginObject;

import java.util.ArrayList;
import java.util.List;

public class Paper extends PluginObject {

    private String mAuthor;
    private String mTitle;
    private String mAbstract;
    private List<Section> mSections;
    private List<Bitmap> mImages;

    public Paper(String author, String title, String paperAbstract, List<Section> sections){
        this.mAuthor = author;
        this.mTitle = title;
        this.mAbstract = paperAbstract;
        this.mSections = sections;
    }

    public Paper(){}

    public String getTitle() {
        // Dummy data
        return "What is all the fuzz about?";
    }

    public String getAbstract() {
        // Dummy data
        return "Fuzzing is an automated software testing technique that has proven " +
                "to be remarkably effective in finding bugs and vulnerabilities in various " +
                "programs. Most existing surveys on the topic discuss the conceptual principles of fuzzing. " +
                "The present survey paper attempts to illustrate these concepts with practical examples " +
                "from industry andacademia. This survey is directed at people who are new to the  field of fuzzing  " +
                "as well as people with more experience,who want to refresh their general knowledge " +
                "on the topic.";
    }

    public List<Section> getSections() {
        // Dummy data
        List<Section> sections = new ArrayList<>();
        Section sect1 = new Section("Introduction", "Software security is becoming " +
                "increasingly more im-portant. With the Internet of Things, more and moredevices are connected " +
                "to the internet. Usually, program-mers use low-level languages like C or C++ to programthese devices." +
                " However, these languages do not providemany  security  guarantees,  which  makes  many  of  the devices" +
                " prone to bugs and vulnerabilities.Software testing and finding bugs has been a manualtask for a long time, " +
                "but in the last few years, bothacademia and industry have made some efforts to automatethis process." +
                " Some automated techniques and tools for bugfinding exist that operate on source code or binary" +
                " codewith debugging information, e.g. STACK[1] andSCAN-BUILD[2]. Nevertheless, the focus of this paper " +
                "will beon techniques that operate on the binary file only, strippedof any debugging information." +
                "Techniques that operate on program binaries withoutdebugging information have some advantages compared" +
                "to techniques that need source code or debugging inform-ation. First, people often do not have access " +
                "to the sourcecode of the programs they use. Using tools that onlyneed binary files, they can still check " +
                "for vulnerabilitiesin these programs. When they detect vulnerabilities, theycan notify the developers " +
                "and ask for a patch. Second,techniques that operate on source code cannot detect allvulnerabilities," +
                " since some vulnerabilities are introducedduring compilation. That can happen because there isnot " +
                "necessarily a one-to-one mapping between the binarycode generated by the compiler or tool chain," +
                " and thesource code. This discrepancy between source and binarycode can occur because different " +
                "compilers might handleundefined behaviour in different ways, such as in the caseof signed integer " +
                "overflow in C and C++. The compilerdoes not have to take signed integer overflow into accountwhen optimising, " +
                "and because of this, it might evaluate theconditional statementif (x + 1 x)as always true,and " +
                "omit the conditional statement altogether, potentiallyintroducing a vulnerability in the code. " +
                "As these kinds of“bugs” are not immediately obvious from the source code,tools that operate on " +
                "binary files are more widely applic-able and can discover more bugs than other techniques." +
                "A series of different techniques have emerged to auto-matically find vulnerabilities in binaries, " +
                "and even auto-matically craft exploits, to show that the found vulnerabil-ities are indeed " +
                "exploitable and that they should be fixed assoon as possible. Two large categories exist in " +
                "automatictesting methods1)Static testing techniquesreason about the programwithout executing it. " +
                "Almost all static techniquesneed a control flow graph to operate. Some toolslike IDA PRO[3],ANGR[4] " +
                "and JAKSTAB[5]provide this functionality already, so they can furtheruse static analysis methods on " +
                "the resulting controlflow graph. Static testing techniques include flowmodelling, which analyses " +
                "control flow graphs tofind certain program properties such as the absenceof bugs, and data modelling," +
                " which reasons about thedata used by a program to find vulnerabilities. Manytools exist to perform " +
                "these tasks automatically,for example the BINCATplugin for IDA PRO[6],SCANBUILD[2] and JAKSTAB[5]." +
                "These static techniques have some main drawbacks.When one of these techniques finds a vulnerability," +
                "it does not provide information on how to triggerthe bug. The vulnerability then has to be verified " +
                "manually. Also, those techniques typically sufferfrom a high rate of false positives. " +
                "A false positive occurs when a tool finds a vulnerability, butthe found vulnerability is actually harmless." +
                " Thisis because the techniques try to reason about theprogram in a highly abstract domain, " +
                "reducing thesemantic insight of the techniques. That is, they donot know why a certain execution " +
                "path is taken.2)Dynamic techniquesexamine a program during itsexecution. " +
                "Two main approaches exist in dynamictesting methods. The first one is symbolic executionwhich " +
                "was first proposed in 1976 by King [7].A program is executed with a symbolic input and then " +
                "a constraint solver is used to find a satisfyingcondition for the inputs on the program. " +
                "The secondapproach is fuzzing. Fuzzing is a simple, yet effect-ive technique for finding bugs " +
                "in code that was firstproposed by Milleret al.in 1988 [8]. The main ideais the following the " +
                "fuzzer executes a program withrandom test inputs and hopes that these inputs willtrigger software errors." +
                "While both static and dynamic techniques are useful,\n" +
                "2in practice, the industry tends to prefer the dynamic tech-niques. Most notably, " +
                "fuzzing has become an importantsoftware testing technique in industry, with big companies like " +
                "Microsoft and Google using whitebox fuzzers that useextra information about the program to find bugs" +
                " moreeffectively. One example is SAGE [9]. A notable result isthat SAGE found roughly one third of all " +
                "the discoveredbugs in Windows 7. Even more remarkable, SAGE typ-ically runs last after all other " +
                "automatic testing tools.This means that SAGE found bugs that other techniques,such as static techniques " +
                "and blackbox fuzzing techniques(which do not use any information about the programbehaviour), " +
                "were unable to find. Furthermore, Microsoftand Google recently provided ‘Fuzzing as a Service’ " +
                "toapplication developers with tools such as MSRD [10] andOSS-FUZZ[11].In addition, academia seem t" +
                "o take a steadily increasinginterest in fuzzing as well. According to a survey byLianget al., " +
                "the number of papers about fuzzing hasincreased quadratically over the years since 1990 [12].Clearly, " +
                "fuzzing has become an indispensable techniqueto automate software testing. In the following sections, " +
                "thispaper aims to give a general overview about what fuzzingis, what challenges it faces and how these " +
                "challenges canbe mitigated.In Section II, we explain the basic concept of fuzzing,and how it works in a" +
                " bit more detail. Second, Section IIIdiscusses some key problems with fuzzing along with howthey might " +
                "be solved. One specific way to solve theseproblems makes use of symbolic execution. Section IV ex-plains" +
                " how symbolic execution can be used in combinationwith fuzzing, and discusses some implementations of th" +
                "istechnique. Lastly, other approaches that improve fuzzingare shortly reviewed in Section V. This is not" +
                " the mainfocus, but they are worth mentioning, since they might aswell be equal counterparts to symbolic" +
                " execution (or evenwork in combination with it).\n");


        Section sect2 = new Section("Fuzzing", "Fuzzing (also called fuzz testing) can be defined as: " +
                "“ahighly automated testing technique that covers numerousboundary cases using invalid data (from files, " +
                "networkprotocols, API calls, and other targets) as application inputto better ensure the absence of " +
                "exploitable vulnerabilit-ies” [13].Fuzzing on its own is simple: supply some random dataat the input, " +
                "and wait until the software crashes. The hard(and creative) part is to generate inputs that trigger " +
                "errorsin the program.The high-level overview of a fuzzer is displayed inFigure 1. The dotted box " +
                "encapsulates what is containedwithin a fuzzer. A fuzzer works as follows [12]: first, theuser specifies" +
                " atarget program(the program that needstesting) and optionally submits aseed fileorspecification.Second, " +
                "one of two things happens:1) The code passes through themonitorwhich analysesthe input and tries to " +
                "discover information aboutthe structure of the code. The monitor might findways to increase code cove" +
                "rage, for example, byreading trace information. Tracing is a form of log-ging information, which can be" +
                " tracked usingcodeFigure 1.  A high-level view of a fuzzer [12].instrumentation. The information from th" +
                "e monitoris then supplied to thetest case generator.2) The code is passed directly to thetest case genera" +
                "-tor. In this case, the monitor might not be present,which may happen if the fuzzer is not intendedto ut" +
                "ilise code information. When code informationis omitted or not available, the fuzzer becomes ablackbox f" +
                "uzzer. The power of blackbox fuzzinglies in the fact that it works fast and is simpleto use. But there is" +
                " no such thing as a free meal.Blackbox fuzzing has many drawbacks, which willbe explained in Section III." +
                "Next, the test case generator generates test cases. Atest case should be tailored to be valid enough so th" +
                "atit can penetrate into the interesting parts of the code,since invalid inputs will be rejected almost imm" +
                "ediatelyby the program. Still, it must be ‘invalid’ enough to findbugs, since completely valid inputs foll" +
                "ow program pathsthat are already tested quite extensively by the applicationdeveloper or users. This can b" +
                "e achieved either usingmutations in the input file, or using a grammar:1)Mutations of the input file:The t" +
                "est case generatorcreates test cases by mutating the inputs specifiedin the seed files. If no seed file is" +
                " specified, theinput is chosen at random. In case of blackboxfuzzing, these mutations are random changes, " +
                "suchas flipping or reordering bits and bytes in the input.In the other case, when a monitorisavailable,the" +
                " discovered runtime information can be used todetermine more relevant mutations, which are ableto penetrat" +
                "e deeper into the program’s code.2)A grammar: This is less obvious: inputs are gener-ated based on a speci" +
                "fic set of rules or agrammar.One example is the grammar for the C programminglanguage, which describes the" +
                " set of rules everyC programmer has to adhere to when writing aprogram. Other examples include PDF documen" +
                "ts,PNG images, MPEG videos, and TCP packets. Tomake sure the input generated by the test casegenerator is " +
                "able to pass through the early parsing2\n" +
                "3stages, it should, for the most part, obey the rulesdescribed in the relevant grammar.Next to last is" +
                " thebug detector. In summary, thiselement analyses every error the program raises or whatcaused the progra" +
                "m to crash. Potential exploits are foundby using this information.Lastly, thebug filterfilters out actual exp" +
                "loits. Auto-mated ways exist to filter the bugs, but currently, there areno state-of-the-art methods. That is wh" +
                "y this is often doneby hand and is in that case not part of the fuzzer.");
        sections.add(sect1);
        sections.add(sect2);
        return sections;
    }

    public List<Bitmap> getImages() {
        // Dummy data
        return null;
    }

    public static PluginObject fromJson(String json){
        return mGson.fromJson(json, PluginObject.class);
    }

}
